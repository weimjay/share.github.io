<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git常用命令</title>
    <url>/2019/10/16/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>1、 查看远程所有分支</p>
<pre><code>git branch -r</code></pre><p>2、查看所有分支</p>
<pre><code>git branch -a</code></pre><p>3、拉取远程分支（如果不是origin，则需要换成对应的名称）</p>
<pre><code>git remote update origin --prune</code></pre><p>4、创建分支</p>
<pre><code>git checkout -b example</code></pre><a id="more"></a>

<p>5、切换分支</p>
<pre><code>git checkout example</code></pre><p>6、查看当前分支</p>
<pre><code>git branch</code></pre><p>7、拉取当前分支代码</p>
<pre><code>git pull origin example</code></pre><p>8、如果在远程服务器上有代码更新，直接丢弃所有更改的命令</p>
<pre><code>git checkout ./</code></pre><p>9、解决pull时提示冲突</p>
<pre><code>git reset --hard FETCH_HEAD</code></pre>]]></content>
  </entry>
  <entry>
    <title>Go 1.13正式发布</title>
    <url>/2019/09/05/Go%201.13%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<p>今天 Go 1.13 终于发布了，虽然比预期延迟了半个月之久，但毕竟迟到总比不到好。</p>
<p>Go 1.13 的发布为 Go 带来了不少变化（详见：<a href="https://golang.org/doc/go1.13" target="_blank" rel="noopener">https://golang.org/doc/go1.13</a> ），有些变化可能是开发者无法直接感觉到的，但有些又是和开发者日常开发息息相关的。其中，Go modules 的扶正就是这次 Go 1.13 发布中开发者能直接感觉到的最大变化。</p>
<a id="more"></a>

<p>Go modules 最早发布于 Go 1.11，经过两个版本的更新后，它作为依赖管理解决方案来说现在已经变得光彩夺目。随着 Go modules 一起被发布的还有一个叫做 Module proxy protocol 的协议，通过它我们可以搭建 Go 模块代理，最后交由 GOPROXY 环境变量以指引 go 命令后续在抓取模块时的途径。对于咱们中国的开发者来说，一个优秀的 Go 模块代理可以帮助我们解决很多问题。比如 Go 语言中最知名的 <code>golang.org/x/...</code> 模块在中国大陆是无法访问到的，以前我们会用很多其他的办法来抓取他们，而若依靠一个可以访问到它们的模块代理，那么将事半功倍。更因为 Go 1.13 将 GOPROXY 默认成了中国大陆无法访问的 <code>https://proxy.golang.org</code> ，所以我们中国的开发者从今以后必须先修改 GOPROXY 才能正常使用 go 来开发应用了。为此，我们联合中国备受信赖的云服务提供商七牛云专门为咱们中国开发者而打造了一个 Go 模块代理：goproxy.cn。</p>
<p>goproxy.cn 是目前中国最可靠的 Go 模块代理，对于这点，如果有人存在质疑可以一一测试比对列表中所有能在国内访问的代理。至于那个和 goproxy.cn域名比较相近的 goproxy.io，我之前已经发表过一篇实测文章（详见：<a href="https://studygolang.com/topics/9994" target="_blank" rel="noopener">https://studygolang.com/topics/9994</a> ）。</p>
<p>goproxy.cn 是一个非营利性项目，目标是为中国和世界上其他地方的 Gopher 们提供一个免费的、可靠的、持续在线的且经过 CDN 加速的模块代理。正因为 goproxy.cn 由中国 Go 语言领域第一个吃螃蟹的大公司七牛云运行，所以它的稳定性和运行速度都是毋庸置疑的，如果你的网络环境本身不差的情况下，它能快到让你不可思议，比 <code>go get</code> 传统的抓取方式快上了不止几倍。有人可能会问阿里云的那个 mirrors.aliyun.com/goproxy 也很快，而且阿里云也是大厂，为什么不用阿里云的模块代理。我只能说，当我在使用阿里云的代理做初始化 github.com/kubernetes/kubernetes 的测试时，出现了大量的 404 错误以至于初始化操作无法完成……而且它还不支持代理 <code>GOSUMDB</code> 的默认值也就是 sum.golang.org，因此你还得手动修改 GOSUMDB 才能够正常使用 go。在速度旗鼓相当的情况下，为什么不考虑直接使用一个更稳定、高可用的呢？而且毕竟 goproxy.cn 这个域名也很好记不是嘛～你只用记住 goproxy 和 .cn，就没了。<br>Q&amp;A<br>问：在 Go 1.13 中如何使用 goproxy.cn？<br>答：<code>go env -w GOPROXY=https://goproxy.cn,direct</code> </p>
<p>问：在 Go 1.13 之前如何使用 goproxy.cn？<br>答：同样也是设置环境变量即可，但是得你手动配置，而且还不能使用上述的那个 <code>,direct</code> 后缀，因为那是 Go 1.13 刚加的特性。详细配置方法可以参见 <a href="https://goproxy.cn" target="_blank" rel="noopener">https://goproxy.cn</a> 的 README 文件。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Centos7搭建Go开发环境</title>
    <url>/2019/01/10/Centos7%E6%90%AD%E5%BB%BAGo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>1、设置静态IP，虚拟机网络设置选择桥接</p>
<pre><code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></pre><p>具体配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=a7dc20d2-10ed-42e9-943b-b72c9cb5c2b9</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line"></span><br><span class="line">IPADDR=192.168.3.180</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.3.1</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>2、安装vmware-tools<br>(1)安装GCC</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br></pre></td></tr></table></figure>

<p>(2)解决The path “” is not a valid path to the 3.10.0-693.el7.x86_64 kernel headers.出现该问题是找不到内核头文件，需要安装头文件，正确的安装命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install &quot;kernel-devel-uname-r == $(uname -r)&quot;</span><br></pre></td></tr></table></figure>

<p>3、安装Go环境</p>
<ul>
<li><p>下载安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install wget vim</span><br><span class="line"></span><br><span class="line">wget https://dl.google.com/go/go1.11.4.linux-amd64.tar.gz</span><br><span class="line">tar -C /usr/local -xzf go1.11.4.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line">//在最后一行添加</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br><span class="line">exprot GOPATH=/mnt/hgfs/E/AMP/www/gostudy</span><br><span class="line">//:wq保存退出后source一下</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">//执行go version，如果显示版本号，表示Go环境安装成功。</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装Git</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install git</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装调试工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get -u github.com/go-delve/delve/cmd/dlv</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>完美的Hexo多电脑同步方法</title>
    <url>/2018/10/18/%E5%AE%8C%E7%BE%8E%E7%9A%84Hexo%E5%A4%9A%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<div class="note warning"><p>我们经常需要在公司或者家庭多台电脑上完成hexo博客的撰写和发布工作，这就涉及到hexo多电脑的同步问题。</p></div>
<p>网上的方案基本上都是多分支方案。也即，在同一个仓库创建两个分支：</p>
<ul>
<li>hexo分支 – 用来保存所有hexo的源文件</li>
<li>master分支 – 用来保存hexo生成的博客文件</li>
</ul>
<p>在创建GitHub Pages或者Coding Pages时，以master分支为pages分支。hexo的deploy指向master分支部署pages，源文件指向hexo分支。</p>
<p>但是这里有一个巨大的问题，就是多分支的方案让完整的Hexo源文件暴露在了公开的仓库。一些hexo博客采用了leancloud阅读次数管理、多说评论等服务，其私有secret key也暴露在公开仓库分支了。如果对这些配置的_config.yml进行单独管理的话，又不能在另一台电脑直接git pull同步，非常的麻烦。</p>
<a id="more"></a>

<p>所以hexo最完美的多电脑同步方法是，创建两个仓库：</p>
<p>hexo私有仓库 – 用来保存所有hexo的源文件<br>master公开仓库 – 用来保存hexo生成的博客文件<br>下面来具体讲讲实现方法。</p>
<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>这里假设读者已经搭建好了hexo的博客系统，实现了：</p>
<ol>
<li>使用hexo d -g部署博客</li>
<li>实现了发布hexo到github pages</li>
<li>自定义了next等第三方主题</li>
</ol>
<h1 id="Let’s-go"><a href="#Let’s-go" class="headerlink" title="Let’s go!"></a>Let’s go!</h1><h2 id="创建私有仓库"><a href="#创建私有仓库" class="headerlink" title="创建私有仓库"></a>创建私有仓库</h2><p>注册一个Coding账号，然后创建一个私有项目，名称为hexo</p>
<h2 id="建立本地git仓库"><a href="#建立本地git仓库" class="headerlink" title="建立本地git仓库"></a>建立本地git仓库</h2><p>进入你现有的hexo文件夹，删除第三方主题的git配置，如对next主题</p>
<pre>rm -fr ./themes/next/.git/</pre>

<p>然后建立本地的git仓库</p>
<pre>git init</pre>

<p>创建一个.gitignore文件，并放在Hexo的根目录，内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure>

<h2 id="push到私有仓库"><a href="#push到私有仓库" class="headerlink" title="push到私有仓库"></a>push到私有仓库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin https://git.coding.net/&lt;yourname&gt;/hexo.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;my first private hexo&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>这样，就完成了本地hexo源码的全备份</p>
<h1 id="在另一台电脑进行hexo写作"><a href="#在另一台电脑进行hexo写作" class="headerlink" title="在另一台电脑进行hexo写作"></a>在另一台电脑进行hexo写作</h1><p>上面已经完成了hexo的全备份，那么如果在另一台电脑进行hexo编辑呢？<br>当然首先你也要完成node/npm/hexo/git等环境的搭建和配置。</p>
<h2 id="hexo拉取"><a href="#hexo拉取" class="headerlink" title="hexo拉取"></a>hexo拉取</h2><pre>git clone https://git.coding.net/<yourname>/hexo.git</yourname></pre>
<p>这样你就拥有了你的所有hexo源文件</p>
<h2 id="hexo文章编写和发布"><a href="#hexo文章编写和发布" class="headerlink" title="hexo文章编写和发布"></a>hexo文章编写和发布</h2><p>尽管拉取下来了，还需要建立一下hexo的环境，这里需要格外注意的一点是：<br>千万不要用hexo init命令。原因是当前目录已经建立了git仓库环境, <code>hexo init</code>会覆盖到当前的git环境，重建一个新的，这样和我们的私有hexo源码仓库脱离了联系。</p>
<p>正确的做法是：</p>
<pre>npm install</pre>
<p>因为<code>package.jso</code>里面已经保存了hexo的必备资源包信息，<code>npm install</code>后hexo环境就建立起来了。</p>
<p>接下来就进行正常的编写和发布就好。<br>本地预览的命令还是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>Hexo的发布命令是<code>hexo d</code>。</p>
<p>最后执行<code>git status</code>把更改的新文件<code>git add</code>和<code>git commit</code>，最后<code>git push</code>到私有仓库，又会完成hexo源码仓库的同步。</p>
<h2 id="hexo仓库更新"><a href="#hexo仓库更新" class="headerlink" title="hexo仓库更新"></a>hexo仓库更新</h2><p>下次进行hexo仓库拉取时执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch --all #将git上所有文件拉取到本地</span><br><span class="line">git reset --hard origin/master  #强制将本地内容指向刚刚同步git云端内容</span><br></pre></td></tr></table></figure>

<p>至此，我们就实现了在多台电脑自由发布文章。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx下使Thinkphp URL模式支持PATHINFO和REWRITE</title>
    <url>/2018/07/17/Nginx%E4%B8%8B%E4%BD%BFThinkphp-URL%E6%A8%A1%E5%BC%8F%E6%94%AF%E6%8C%81PATHINFO%E5%92%8CREWRITE/</url>
    <content><![CDATA[<p>首先tp5的访问目录指向到webroot/public文件夹中。<br>thinkphp的url访问：<code>http://serverName/index.php</code>（或者其它应用入口文件）/模块/控制器/操作/[参数名/参数值…]，这个需要支持pathinfo，Apache默认支持，而Nginx不支持。<br>1.php.ini中的配置参数cgi.fix_pathinfo = 1<br>2.修改nginx.conf文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~ \.php(.*)$ &#123;</span><br><span class="line">    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">#下面两句是给fastcgi权限，可以支持 ?s=/module/controller/action 的url访问模式</span><br><span class="line">    fastcgi_split_path_info  ^((?U).+\.php)(/?.+)$;</span><br><span class="line">    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">#下面两句才能真正支持 index.php/index/index/index 的pathinfo模式</span><br><span class="line">    fastcgi_param  PATH_INFO  $fastcgi_path_info;</span><br><span class="line">    fastcgi_param  PATH_TRANSLATED  $document_root$fastcgi_path_info;</span><br><span class="line">    include        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制代码<br>这样就能在linux,nginx环境下运行tp5了。<br>3.去掉/index.php/<br>修改nginx.conf文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">       index  index.html index.htm index.php;</span><br><span class="line">            #autoindex  on;</span><br><span class="line">          if (!-e $request_filename) &#123;</span><br><span class="line">            rewrite  ^(.*)$  /index.php?s=/$1  last;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax跨域问题解决</title>
    <url>/2017/12/18/ajax%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>ajax跨域访问是一个老问题了，解决方法很多，比较常用的是JSONP方法，JSONP方法是一种非官方方法，而且这种方法只支持GET方式，不如POST方式安全。</p>
<p>即使使用jQuery的jsonp方法，type设为POST，也会自动变为GET。</p>
<p>官方问题说明：</p>
<div class="note "><p>“script”: Evaluates the response as JavaScript and returns it as plain text. Disables caching by appending a query string parameter, “_=[TIMESTAMP]”, to the URL unless the cache option is set to true.Note: This will turn POSTs into GETs for remote-domain requests.</p></div>

<p>如果跨域使用POST方式，可以使用创建一个隐藏的iframe来实现，与ajax上传图片原理一样，但这样会比较麻烦。</p>
<a id="more"></a>

<p>因此，通过设置Access-Control-Allow-Origin来实现跨域访问比较简单。</p>
<p>例如：客户端的域名是<code>www.client.com</code>，而请求的域名是<code>www.server.com</code><br>如果直接使用ajax访问，会有以下错误</p>
<div class="note danger"><p>XMLHttpRequest cannot load <a href="http://www.server.com/server.php" target="_blank" rel="noopener">http://www.server.com/server.php</a>. No ‘Access-Control-Allow-Origin’ header is present on the requested resource.Origin ‘<a href="http://www.client.com&#39;" target="_blank" rel="noopener">http://www.client.com&#39;</a> is therefore not allowed access.</p></div>

<p>在被请求的Response header中加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 指定允许其他域名访问  </span><br><span class="line">header(&apos;Access-Control-Allow-Origin:*&apos;);  </span><br><span class="line">// 响应类型  </span><br><span class="line">header(&apos;Access-Control-Allow-Methods:POST&apos;);  </span><br><span class="line">// 响应头设置  </span><br><span class="line">header(&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;);  </span><br><span class="line">就可以实现ajax POST跨域访问了。</span><br></pre></td></tr></table></figure>

<p>代码如下：<br>client.html 路径：<code>http://www.client.com/client.html</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;  </span><br><span class="line">&lt;html&gt;  </span><br><span class="line"> &lt;head&gt;  </span><br><span class="line">  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;  </span><br><span class="line">  &lt;title&gt; 跨域测试 &lt;/title&gt;  </span><br><span class="line">  &lt;script src=&quot;//code.jquery.com/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt;  </span><br><span class="line"> &lt;/head&gt;  </span><br><span class="line">  </span><br><span class="line"> &lt;body&gt;  </span><br><span class="line">    &lt;div id=&quot;show&quot;&gt;&lt;/div&gt;  </span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    $.post(&quot;http://www.server.com/server.php&quot;,&#123;name:&quot;fdipzone&quot;,gender:&quot;male&quot;&#125;)  </span><br><span class="line">      .done(function(data)&#123;  </span><br><span class="line">        document.getElementById(&quot;show&quot;).innerHTML = data.name + &apos; &apos; + data.gender;  </span><br><span class="line">      &#125;);  </span><br><span class="line">    &lt;/script&gt;  </span><br><span class="line"> &lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>server.php 路径：<code>http://www.server.com/server.php</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">$ret = array(  </span><br><span class="line">    &apos;name&apos; =&gt; isset($_POST[&apos;name&apos;])? $_POST[&apos;name&apos;] : &apos;&apos;,  </span><br><span class="line">    &apos;gender&apos; =&gt; isset($_POST[&apos;gender&apos;])? $_POST[&apos;gender&apos;] : &apos;&apos;  </span><br><span class="line">);  </span><br><span class="line">  </span><br><span class="line">header(&apos;content-type:application:json;charset=utf8&apos;);  </span><br><span class="line">header(&apos;Access-Control-Allow-Origin:*&apos;);  </span><br><span class="line">header(&apos;Access-Control-Allow-Methods:POST&apos;);  </span><br><span class="line">header(&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;);  </span><br><span class="line">  </span><br><span class="line">echo json_encode($ret);</span><br></pre></td></tr></table></figure>

<p>Access-Control-Allow-Origin: * 表示允许任何域名跨域访问<br>如果需要指定某域名才允许跨域访问，只需把Access-Control-Allow-Origin: * 改为Access-Control-Allow-Origin: 允许的域名<br>例如：<code>header(&#39;Access-Control-Allow-Origin: http://www.client.com&#39;);</code></p>
<p>如果需要设置多个域名允许访问，这里需要用php处理一下<br>例如允许 <code>www.client.com</code> 与 <code>www.client2.com</code> 可以跨域访问<br>server.php 修改为</p>
<pre><code>&lt;?php  
$ret = array(  
    &apos;name&apos; =&gt; isset($_POST[&apos;name&apos;])? $_POST[&apos;name&apos;] : &apos;&apos;,  
    &apos;gender&apos; =&gt; isset($_POST[&apos;gender&apos;])? $_POST[&apos;gender&apos;] : &apos;&apos;  
);  

header(&apos;content-type:application:json;charset=utf8&apos;);  

$origin = isset($_SERVER[&apos;HTTP_ORIGIN&apos;])? $_SERVER[&apos;HTTP_ORIGIN&apos;] : &apos;&apos;;  

$allow_origin = array(  
    &apos;http://www.client.com&apos;,  
    &apos;http://www.client2.com&apos;  
);  

if(in_array($origin, $allow_origin)){  
    header(&apos;Access-Control-Allow-Origin:&apos;.$origin);  
    header(&apos;Access-Control-Allow-Methods:POST&apos;);  
    header(&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;);  
}  

echo json_encode($ret);  
</code></pre>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>避免PHP-FPM内存泄漏导致内存耗尽</title>
    <url>/2017/11/25/%E9%81%BF%E5%85%8DPHP-FPM%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E8%80%97%E5%B0%BD/</url>
    <content><![CDATA[<p>PHP-FPM如果出现存存泄漏问题可能导致服务器内存不足从而导致服务器资源用尽了，这样就会导致网站无法访问了，下面一起来看一篇避免PHP-FPM内存泄漏导致内存耗尽的配置。</p>
<p>对于PHP-FPM多进程的模式，想要避免内存泄漏问题很简单,就是要让PHP-CGI在处理一定数量进程后退出即可。</p>
<p>否则PHP程序或第三方模块(如Imagemagick扩展)导致的内存泄漏问题会导致内存耗尽或不足。</p>
<a id="more"></a>

<p>php-fpm.conf中有相关配置：</p>
<p>#请自行按需求配置</p>
<p>pm.max_requests = 1024</p>
<p>实际上还有另一个跟它有关联的值max_children，这个是每次php-fpm会建立多少个进程，这样实际上的内存消耗是max_children * max_requests * 每个请求使用内存。</p>
<p>另外一些粗暴的方法包括建立cron kill掉占用内存过多的php-cgi，</p>
<p>1.检查php进程的内存占用，杀掉内存使用超额的进程</p>
<p>一般情况下，如果php-cgi进程占用超过1%的内存，就得考虑一下是否要杀掉它了。因为普通情况下，php-cgi进程一般占用0.2%或以下。</p>
<p>这里提供一个脚本供各位使用，就是放在cron任务里，每分钟执行一次。</p>
<p>使用crontab -e 命令，然后添加如下调度任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * * * * /bin/bash /usr/local/script/kill_php_cgi.sh</span><br></pre></td></tr></table></figure>

<p>kill_php_cgi.sh脚本如下</p>
<p>#!/bin/sh</p>
<p>#如果是要杀掉php-fpm的进程，下面的语句中php-cgi请改成php-fpm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pids=`ps -ef|grep php-cgi|grep -v &quot;grep&quot;|grep -v &quot;$0&quot;| awk &apos;&#123;print $2&#125;&apos;` </span><br><span class="line">if [ &quot;$pids&quot; != &quot;&quot; ];then for  pid  in   $pids; </span><br><span class="line">do kill -9 $pid done fi</span><br></pre></td></tr></table></figure>

<p>2.增加内存，将PHP_FCGI_MAX_REQUESTS的值设置成跟你内存总存储量相对应的值。</p>
<p>3.优化程序,降低处理每次请求占用的内存大小。</p>
<p>如果PHP-FPM能够提供配置子进程内存超过指定大小就被kill，那就省事多了。</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title>解决php5.6的curl扩展开启失败的问题</title>
    <url>/2017/10/25/%E8%A7%A3%E5%86%B3php5-6%E7%9A%84curl%E6%89%A9%E5%B1%95%E5%BC%80%E5%90%AF%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天要用到php的curl扩展，将php.ini中的;extension=php_curl.dll的注释去掉后，重启apache后仍然报Call to undefined function curl_init()的错误。<br>搜索多次，尝试很多方法，也不能成功的将curl成功开启。<br>最后在官方说明文档中的 <a href="http://php.net/manual/zh/curl.installation.php" target="_blank" rel="noopener">http://php.net/manual/zh/curl.installation.php</a> 这个页面得到了提示，<br><strong>只要将php安装目录下的libssh2.dll复制到apache的bin目录</strong>，并重新启动apache，于是curl成功开启。此事让我意识到了文档的重要性，大伙也得注意多在文档中寻找答案。</p>
<p>测试环境：</p>
<p>httpd-2.4.23-x64-vc11<br>mysql-5.6.26-winx64<br>php-5.6.23-Win32-VC11-x64</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title>Redis消息队列</title>
    <url>/2017/10/18/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Redis不仅可作为缓存服务器，还可用作消息队列。它的列表类型天生支持用作消息队列。如下图所示：</p>
<p><img src="https://i.loli.net/2019/12/19/ZV3CB1KvxdgS78T.png" alt></p>
<p>由于Redis的列表是使用双向链表实现的，保存了头尾节点，所以在列表头尾两边插取元素都是非常快的。</p>
<a id="more"></a>

<h2 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在业务发展过程中，会出现一些需要延时处理的场景，比如：<br>a.订单下单之后超过30分钟用户未支付，需要取消订单；<br>b.订单一些评论，如果48h用户未对商家评论，系统会自动产生一条默认评论；<br>c.点我达订单下单后，超过一定时间订单未派出，需要超时取消订单等。<br>处理这类需求，比较直接简单的方式就是定时任务轮训扫表。这种处理方式在数据量不大的场景下是完全没问题，但是当数据量大的时候高频的轮训数据库就会比较的耗资源，导致数据库的慢查或者查询超时。所以在处理这类需求时候，采用了延时队列来完成。</p>
<h3 id="几种延时队列"><a href="#几种延时队列" class="headerlink" title="几种延时队列"></a>几种延时队列</h3><p>延时队列就是一种带有延迟功能的消息队列。下面会介绍几种目前已有的延时队列：</p>
<h4 id="1-Rocketmq延时队列"><a href="#1-Rocketmq延时队列" class="headerlink" title="1.Rocketmq延时队列"></a>1.Rocketmq延时队列</h4><p>优点：消息持久化，分布式<br>缺点：不支持任意时间精度，只支持特定level的延时消息</p>
<h4 id="2-Rabbitmq延时队列（TTL-DLX实现）"><a href="#2-Rabbitmq延时队列（TTL-DLX实现）" class="headerlink" title="2.Rabbitmq延时队列（TTL+DLX实现）"></a>2.Rabbitmq延时队列（TTL+DLX实现）</h4><p>优点：消息持久化，分布式<br>缺点：延时相同的消息必须扔在同一个队列</p>
<h3 id="Redis实现的延时消息队列适合的项目特点："><a href="#Redis实现的延时消息队列适合的项目特点：" class="headerlink" title="Redis实现的延时消息队列适合的项目特点："></a>Redis实现的延时消息队列适合的项目特点：</h3><ul>
<li>Spring框架管理对象</li>
<li>有消息需求，但不想维护mq中间件</li>
<li>有使用redis</li>
<li>对消息持久化并没有很苛刻的要求</li>
</ul>
<h3 id="Redis实现的延时消息队列思路"><a href="#Redis实现的延时消息队列思路" class="headerlink" title="Redis实现的延时消息队列思路"></a>Redis实现的延时消息队列思路</h3><p>Redis由于其自身的Zset数据结构，本质就是Set结构上加了个排序的功能，除了添加数据value之外，还提供另一属性score，这一属性在添加修改元素时候可以指定，每次指定后，Zset会自动重新按新的值调整顺序。可以理解为有两列字段的数据表，一列存value,一列存顺序编号。操作中key理解为zset的名字，那么对延时队列又有何用呢？<br>试想如果score代表的是想要执行时间的时间戳，在某个时间将它插入Zset集合中，它变会按照时间戳大小进行排序，也就是对执行时间前后进行排序，这样的话，起一个死循环线程不断地进行取第一个key值，如果当前时间戳大于等于该key值的socre就将它取出来进行消费删除，就可以达到延时执行的目的, 注意不需要遍历整个Zset集合，以免造成性能浪费。<br>Zset的排列效果如下图：<br><img src="https://i.loli.net/2019/12/19/qbrJospzwyBSxfK.jpg" alt></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP排序算法</title>
    <url>/2017/10/10/PHP%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/12/19/E2a5dGzxJOgyBcH.jpg" alt></p>
<a id="more"></a>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="https://i.loli.net/2019/12/19/7h2cTFWDjEpwnkB.gif" alt></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span><span class="params">($arr)</span> </span>&#123;</span><br><span class="line">    $len = count($arr);</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt; $len; $i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; $len - $i; $j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($arr[$j] &gt; $arr[$j + <span class="number">1</span>]) &#123;</span><br><span class="line">                $temp = $arr[$j + <span class="number">1</span>];</span><br><span class="line">                $arr[$j + <span class="number">1</span>] = $arr[$j];</span><br><span class="line">                $arr[$j] = $temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="https://i.loli.net/2019/12/19/iFpybzQU24IvJuA.gif" alt></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fastSort</span><span class="params">($arr)</span> </span>&#123;</span><br><span class="line">    $len = count($arr);</span><br><span class="line">    <span class="keyword">if</span> ($len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> $arr;</span><br><span class="line">    &#125;</span><br><span class="line">    $less = [];</span><br><span class="line">    $greater = [];</span><br><span class="line">    $fst = $arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt; $len; $i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($arr[$i] &lt; $fst) &#123;</span><br><span class="line">            $less[] = $arr[$i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $greater[] = $arr[$i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array_merge(fastSort($less), [$fst], fastSort($greater));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><img src="https://i.loli.net/2019/12/19/kX3sGCxheFocIip.gif" alt></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span><span class="params">($arr)</span> </span>&#123;</span><br><span class="line">    $len = count($arr);</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $len; $i++) &#123;</span><br><span class="line">        <span class="comment">//先假设最小值的位置</span></span><br><span class="line">        $p = $i;</span><br><span class="line">        <span class="keyword">for</span> ($j = $i + <span class="number">1</span>; $j &lt; $len; $j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($arr[$p] &gt; $arr[$j]) &#123;</span><br><span class="line">                <span class="comment">//比较发现更小的，记录下最小值的位置，并且在下次比较时采用已知的最小值进行比较</span></span><br><span class="line">                $p = $j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已经确定了当前的最小值的位置，保存到$p中</span></span><br><span class="line">        <span class="comment">//如果发现最小值的位置与当前假设的位置$i不同，则位置互换即可</span></span><br><span class="line">        <span class="keyword">if</span> ($p != $i) &#123;</span><br><span class="line">            $temp = $arr[$i];</span><br><span class="line">            $arr[$i] = $arr[$p];</span><br><span class="line">            $arr[$p] = $temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><img src="https://i.loli.net/2019/12/19/fx5rZsDp7FghUeb.gif" alt></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span><span class="params">($arr)</span> </span>&#123;</span><br><span class="line">    $len = count($arr);</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt; $len; $i++) &#123;</span><br><span class="line">        $temp = $arr[$i];</span><br><span class="line">        <span class="keyword">for</span> ($j = $i - <span class="number">1</span>; $j &gt;= <span class="number">0</span>; $j --) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($temp &lt; $arr[$j]) &#123;</span><br><span class="line">                $arr[$j + <span class="number">1</span>] = $arr[$j];</span><br><span class="line">                $arr[$j] = $temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title>php-redis中文文档</title>
    <url>/2017/09/30/php-redis%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>phpredis是php的一个扩展，效率非常高，有链表排序功能，对创建内存级的模块业务关系很有用。</p>
<p>以下是redis官方提供的命令使用技巧:</p>
<p>下载地址如下：</p>
<p><a href="https://github.com/owlient/phpredis" target="_blank" rel="noopener">https://github.com/owlient/phpredis</a> （支持redis 2.0.4）</p>
<p>Redis::__construct构造函数<br>$redis = new Redis();</p>
<a id="more"></a>

<p>connect, open 链接redis服务<br>参数<br>host: string，服务地址<br>port: int,端口号<br>timeout: float,链接时长 (可选, 默认为 0 ，不限链接时间)<br>注: 在redis.conf中也有时间，默认为300</p>
<p>pconnect, popen 不会主动关闭的链接</p>
<p>setOption 设置redis模式</p>
<p>getOption 查看redis设置的模式</p>
<p>ping 查看连接状态</p>
<p>get 得到某个key的值（string值）<br>如果该key不存在，return false</p>
<p>set 写入key 和 value（string值）<br>如果写入成功，return ture</p>
<p>setex 带生存时间的写入值<br>$redis-&gt;setex(‘key’, 3600, ‘value’); // sets key → value, with 1h TTL.</p>
<p>setnx 判断是否重复的，写入值<br>$redis-&gt;setnx(‘key’, ‘value’);<br>$redis-&gt;setnx(‘key’, ‘value’);</p>
<p>delete  删除指定key的值<br>返回已经删除key的个数（长整数）<br>$redis-&gt;delete(‘key1’, ‘key2’);<br>$redis-&gt;delete(array(‘key3’, ‘key4’, ‘key5’));</p>
<p>ttl<br>得到一个key的生存时间</p>
<p>persist<br>移除生存时间到期的key<br>如果key到期 true 如果不到期 false</p>
<p>mset （redis版本1.1以上才可以用）<br>同时给多个key赋值<br>$redis-&gt;mset(array(‘key0’ =&gt; ‘value0’, ‘key1’ =&gt; ‘value1’));</p>
<p>multi, exec, discard<br>进入或者退出事务模式<br>参数可选Redis::MULTI或Redis::PIPELINE. 默认是 Redis::MULTI<br>Redis::MULTI：将多个操作当成一个事务执行<br>Redis::PIPELINE:让（多条）执行命令简单的，更加快速的发送给服务器，但是没有任何原子性的保证<br>discard:删除一个事务<br>返回值<br>multi()，返回一个redis对象，并进入multi-mode模式，一旦进入multi-mode模式，以后调用的所有方法都会返回相同的对象，只到exec(）方法被调用。</p>
<p>watch, unwatch （代码测试后，不能达到所说的效果）<br>监测一个key的值是否被其它的程序更改。如果这个key在watch 和 exec （方法）间被修改，这个 MULTI/EXEC 事务的执行将失败（return false）<br>unwatch  取消被这个程序监测的所有key<br>参数，一对key的列表<br>$redis-&gt;watch(‘x’);</p>
<p>$ret = $redis-&gt;multi() -&gt;incr(‘x’) -&gt;exec();</p>
<p>subscribe *<br>方法回调。注意，该方法可能在未来里发生改变</p>
<p>publish *<br>发表内容到某一个通道。注意，该方法可能在未来里发生改变</p>
<p>exists<br>判断key是否存在。存在 true 不在 false</p>
<p>incr, incrBy<br>key中的值进行自增1，如果填写了第二个参数，者自增第二个参数所填的值<br>$redis-&gt;incr(‘key1’);<br>$redis-&gt;incrBy(‘key1’, 10);</p>
<p>decr, decrBy<br>做减法，使用方法同incr</p>
<p>getMultiple<br>传参<br>由key组成的数组<br>返回参数<br>如果key存在返回value，不存在返回false<br>$redis-&gt;set(‘key1’, ‘value1’); $redis-&gt;set(‘key2’, ‘value2’); $redis-&gt;set(‘key3’, ‘value3’); $redis-&gt;getMultiple(array(‘key1’, ‘key2’, ‘key3’));<br>$redis-&gt;lRem(‘key1’, ‘A’, 2);<br>$redis-&gt;lRange(‘key1’, 0, -1);</p>
<p>list相关操作<br>lPush<br>$redis-&gt;lPush(key, value);<br>在名称为key的list左边（头）添加一个值为value的 元素</p>
<p>rPush<br>$redis-&gt;rPush(key, value);<br>在名称为key的list右边（尾）添加一个值为value的 元素</p>
<p>lPushx/rPushx<br>$redis-&gt;lPushx(key, value);<br>在名称为key的list左边(头)/右边（尾）添加一个值为value的元素,如果value已经存在，则不添加</p>
<p>lPop/rPop<br>$redis-&gt;lPop(‘key’);<br>输出名称为key的list左(头)起/右（尾）起的第一个元素，删除该元素</p>
<p>blPop/brPop<br>$redis-&gt;blPop(‘key1’, ‘key2’, 10);<br>lpop命令的block版本。即当timeout为0时，若遇到名称为key i的list不存在或该list为空，则命令结束。如果timeout&gt;0，则遇到上述情况时，等待timeout秒，如果问题没有解决，则对keyi+1开始的list执行pop操作</p>
<p>lSize<br>$redis-&gt;lSize(‘key’);<br>返回名称为key的list有多少个元素</p>
<p>lIndex, lGet<br>$redis-&gt;lGet(‘key’, 0);<br>返回名称为key的list中index位置的元素</p>
<p>lSet<br>$redis-&gt;lSet(‘key’, 0, ‘X’);<br>给名称为key的list中index位置的元素赋值为value</p>
<p>lRange, lGetRange<br>$redis-&gt;lRange(‘key1’, 0, -1);<br>返回名称为key的list中start至end之间的元素（end为 -1 ，返回所有）</p>
<p>lTrim, listTrim<br>$redis-&gt;lTrim(‘key’, start, end);<br>截取名称为key的list，保留start至end之间的元素</p>
<p>lRem, lRemove<br>$redis-&gt;lRem(‘key’, ‘A’, 2);<br>删除count个名称为key的list中值为value的元素。count为0，删除所有值为value的元素，count&gt;0从头至尾删除count个值为value的元素，count&lt;0从尾到头删除|count|个值为value的元素</p>
<p>lInsert<br>在名称为为key的list中，找到值为pivot 的value，并根据参数Redis::BEFORE | Redis::AFTER，来确定，newvalue 是放在 pivot 的前面，或者后面。如果key不存在，不会插入，如果 pivot不存在，return -1<br>$redis-&gt;delete(‘key1’); $redis-&gt;lInsert(‘key1’, Redis::AFTER, ‘A’, ‘X’); $redis-&gt;lPush(‘key1’, ‘A’); $redis-&gt;lPush(‘key1’, ‘B’); $redis-&gt;lPush(‘key1’, ‘C’); $redis-&gt;lInsert(‘key1’, Redis::BEFORE, ‘C’, ‘X’);<br>$redis-&gt;lRange(‘key1’, 0, -1);<br>$redis-&gt;lInsert(‘key1’, Redis::AFTER, ‘C’, ‘Y’);<br>$redis-&gt;lRange(‘key1’, 0, -1);<br>$redis-&gt;lInsert(‘key1’, Redis::AFTER, ‘W’, ‘value’);</p>
<p>rpoplpush<br>返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部<br>$redis-&gt;delete(‘x’, ‘y’);<br>$redis-&gt;lPush(‘x’, ‘abc’); $redis-&gt;lPush(‘x’, ‘def’); $redis-&gt;lPush(‘y’, ‘123’); $redis-&gt;lPush(‘y’, ‘456’); // move the last of x to the front of y. var_dump($redis-&gt;rpoplpush(‘x’, ‘y’));<br>var_dump($redis-&gt;lRange(‘x’, 0, -1));<br>var_dump($redis-&gt;lRange(‘y’, 0, -1)); </p>
<p>string(3) “abc”<br>array(1) { [0]=&gt; string(3) “def” }<br>array(3) { [0]=&gt; string(3) “abc” [1]=&gt; string(3) “456” [2]=&gt; string(3) “123” }</p>
<p>SET操作相关<br>sAdd<br>向名称为key的set中添加元素value,如果value存在，不写入，return false<br>$redis-&gt;sAdd(key , value);</p>
<p>sRem, sRemove<br>删除名称为key的set中的元素value<br>$redis-&gt;sAdd(‘key1’ , ‘set1’);<br>$redis-&gt;sAdd(‘key1’ , ‘set2’);<br>$redis-&gt;sAdd(‘key1’ , ‘set3’);<br>$redis-&gt;sRem(‘key1’, ‘set2’);</p>
<p>sMove<br>将value元素从名称为srckey的集合移到名称为dstkey的集合<br>$redis-&gt;sMove(seckey, dstkey, value);</p>
<p>sIsMember, sContains<br>名称为key的集合中查找是否有value元素，有ture 没有 false<br>$redis-&gt;sIsMember(key, value);</p>
<p>sCard, sSize<br>返回名称为key的set的元素个数</p>
<p>sPop<br>随机返回并删除名称为key的set中一个元素</p>
<p>sRandMember<br>随机返回名称为key的set中一个元素，不删除</p>
<p>sInter<br>求交集</p>
<p>sInterStore<br>求交集并将交集保存到output的集合<br>$redis-&gt;sInterStore(‘output’, ‘key1’, ‘key2’, ‘key3’)</p>
<p>sUnion<br>求并集<br>$redis-&gt;sUnion(‘s0’, ‘s1’, ‘s2’);<br>s0,s1,s2 同时求并集</p>
<p>sUnionStore<br>求并集并将并集保存到output的集合<br>$redis-&gt;sUnionStore(‘output’, ‘key1’, ‘key2’, ‘key3’)；</p>
<p>sDiff<br>求差集</p>
<p>sDiffStore<br>求差集并将差集保存到output的集合</p>
<p>sMembers, sGetMembers<br>返回名称为key的set的所有元素</p>
<p>sort<br>排序，分页等<br>参数<br>‘by’ =&gt; ‘some_pattern_<em>‘,<br>‘limit’ =&gt; array(0, 1),<br>‘get’ =&gt; ‘some_other_pattern_</em>‘ or an array of patterns,<br>‘sort’ =&gt; ‘asc’ or ‘desc’,<br>‘alpha’ =&gt; TRUE,<br>‘store’ =&gt; ‘external-key’<br>例子<br>$redis-&gt;delete(‘s’); $redis-&gt;sadd(‘s’, 5); $redis-&gt;sadd(‘s’, 4); $redis-&gt;sadd(‘s’, 2); $redis-&gt;sadd(‘s’, 1); $redis-&gt;sadd(‘s’, 3);<br>var_dump($redis-&gt;sort(‘s’)); // 1,2,3,4,5<br>var_dump($redis-&gt;sort(‘s’, array(‘sort’ =&gt; ‘desc’))); // 5,4,3,2,1<br>var_dump($redis-&gt;sort(‘s’, array(‘sort’ =&gt; ‘desc’, ‘store’ =&gt; ‘out’))); // (int)5</p>
<p>string命令<br>getSet<br>返回原来key中的值，并将value写入key<br>$redis-&gt;set(‘x’, ‘42’);<br>$exValue = $redis-&gt;getSet(‘x’, ‘lol’); // return ‘42’, replaces x by ‘lol’<br>$newValue = $redis-&gt;get(‘x’)’ // return ‘lol’</p>
<p>append<br>string，名称为key的string的值在后面加上value<br>$redis-&gt;set(‘key’, ‘value1’);<br>$redis-&gt;append(‘key’, ‘value2’);<br>$redis-&gt;get(‘key’);</p>
<p>getRange （方法不存在）<br>返回名称为key的string中start至end之间的字符<br>$redis-&gt;set(‘key’, ‘string value’);<br>$redis-&gt;getRange(‘key’, 0, 5);<br>$redis-&gt;getRange(‘key’, -5, -1);</p>
<p>setRange （方法不存在）<br>改变key的string中start至end之间的字符为value<br>$redis-&gt;set(‘key’, ‘Hello world’);<br>$redis-&gt;setRange(‘key’, 6, “redis”);<br>$redis-&gt;get(‘key’);</p>
<p>strlen<br>得到key的string的长度<br>$redis-&gt;strlen(‘key’);</p>
<p>getBit/setBit<br>返回2进制信息</p>
<p>zset（sorted set）操作相关<br>zAdd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。<br>$redis-&gt;zAdd(‘key’, 1, ‘val1’);<br>$redis-&gt;zAdd(‘key’, 0, ‘val0’);<br>$redis-&gt;zAdd(‘key’, 5, ‘val5’);<br>$redis-&gt;zRange(‘key’, 0, -1); // array(val0, val1, val5)</p>
<p>zRange(key, start, end,withscores)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素<br>$redis-&gt;zAdd(‘key1’, 0, ‘val0’);<br>$redis-&gt;zAdd(‘key1’, 2, ‘val2’);<br>$redis-&gt;zAdd(‘key1’, 10, ‘val10’);<br>$redis-&gt;zRange(‘key1’, 0, -1); // with scores $redis-&gt;zRange(‘key1’, 0, -1, true);</p>
<p>zDelete, zRem<br>zRem(key, member) ：删除名称为key的zset中的元素member<br>$redis-&gt;zAdd(‘key’, 0, ‘val0’);<br>$redis-&gt;zAdd(‘key’, 2, ‘val2’);<br>$redis-&gt;zAdd(‘key’, 10, ‘val10’);<br>$redis-&gt;zDelete(‘key’, ‘val2’);<br>$redis-&gt;zRange(‘key’, 0, -1); </p>
<p>zRevRange(key, start, end,withscores)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素.withscores: 是否输出socre的值，默认false，不输出<br>$redis-&gt;zAdd(‘key’, 0, ‘val0’);<br>$redis-&gt;zAdd(‘key’, 2, ‘val2’);<br>$redis-&gt;zAdd(‘key’, 10, ‘val10’);<br>$redis-&gt;zRevRange(‘key’, 0, -1); // with scores $redis-&gt;zRevRange(‘key’, 0, -1, true);</p>
<p>zRangeByScore, zRevRangeByScore<br>$redis-&gt;zRangeByScore(key, star, end, array(withscores， limit ));<br>返回名称为key的zset中score &gt;= star且score &lt;= end的所有元素</p>
<p>zCount<br>$redis-&gt;zCount(key, star, end);<br>返回名称为key的zset中score &gt;= star且score &lt;= end的所有元素的个数</p>
<p>zRemRangeByScore, zDeleteRangeByScore<br>$redis-&gt;zRemRangeByScore(‘key’, star, end);<br>删除名称为key的zset中score &gt;= star且score &lt;= end的所有元素，返回删除个数</p>
<p>zSize, zCard<br>返回名称为key的zset的所有元素的个数</p>
<p>zScore<br>$redis-&gt;zScore(key, val2);<br>返回名称为key的zset中元素val2的score</p>
<p>zRank, zRevRank<br>$redis-&gt;zRevRank(key, val);<br>返回名称为key的zset（元素已按score从小到大排序）中val元素的rank（即index，从0开始），若没有val元素，返回“null”。zRevRank 是从大到小排序</p>
<p>zIncrBy<br>$redis-&gt;zIncrBy(‘key’, increment, ‘member’);<br>如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment</p>
<p>zUnion/zInter<br>参数<br>keyOutput<br>arrayZSetKeys<br>arrayWeights<br>aggregateFunction Either “SUM”, “MIN”, or “MAX”: defines the behaviour to use on duplicate entries during the zUnion.<br>对N个zset求并集和交集，并将最后的集合保存在dstkeyN中。对于集合中每一个元素的score，在进行AGGREGATE运算前，都要乘以对于的WEIGHT参数。如果没有提供WEIGHT，默认为1。默认的AGGREGATE是SUM，即结果集合中元素的score是所有集合对应元素进行SUM运算的值，而MIN和MAX是指，结果集合中元素的score是所有集合对应元素中最小值和最大值。</p>
<p>Hash操作<br>hSet<br>$redis-&gt;hSet(‘h’, ‘key1’, ‘hello’);<br>向名称为h的hash中添加元素key1—&gt;hello</p>
<p>hGet<br>$redis-&gt;hGet(‘h’, ‘key1’);<br>返回名称为h的hash中key1对应的value（hello）</p>
<p>hLen<br>$redis-&gt;hLen(‘h’);<br>返回名称为h的hash中元素个数</p>
<p>hDel<br>$redis-&gt;hDel(‘h’, ‘key1’);<br>删除名称为h的hash中键为key1的域</p>
<p>hKeys<br>$redis-&gt;hKeys(‘h’);<br>返回名称为key的hash中所有键</p>
<p>hVals<br>$redis-&gt;hVals(‘h’)<br>返回名称为h的hash中所有键对应的value</p>
<p>hGetAll<br>$redis-&gt;hGetAll(‘h’);<br>返回名称为h的hash中所有的键（field）及其对应的value</p>
<p>hExists<br>$redis-&gt;hExists(‘h’, ‘a’);<br>名称为h的hash中是否存在键名字为a的域</p>
<p>hIncrBy<br>$redis-&gt;hIncrBy(‘h’, ‘x’, 2);<br>将名称为h的hash中x的value增加2</p>
<p>hMset<br>$redis-&gt;hMset(‘user:1’, array(‘name’ =&gt; ‘Joe’, ‘salary’ =&gt; 2000));<br>向名称为key的hash中批量添加元素</p>
<p>hMGet<br>$redis-&gt;hmGet(‘h’, array(‘field1’, ‘field2’));<br>返回名称为h的hash中field1,field2对应的value</p>
<p>redis 操作相关<br>flushDB<br>清空当前数据库</p>
<p>flushAll<br>清空所有数据库</p>
<p>randomKey<br>随机返回key空间的一个key<br>$key = $redis-&gt;randomKey();</p>
<p>select<br>选择一个数据库<br>move<br>转移一个key到另外一个数据库<br>$redis-&gt;select(0); // switch to DB 0<br>$redis-&gt;set(‘x’, ‘42’); // write 42 to x<br>$redis-&gt;move(‘x’, 1); // move to DB 1<br>$redis-&gt;select(1); // switch to DB 1<br>$redis-&gt;get(‘x’); // will return 42</p>
<p>rename, renameKey<br>给key重命名<br>$redis-&gt;set(‘x’, ‘42’);<br>$redis-&gt;rename(‘x’, ‘y’);<br>$redis-&gt;get(‘y’); // → 42<br>$redis-&gt;get(‘x’); // → <code>FALSE</code></p>
<p>renameNx<br>与remane类似，但是，如果重新命名的名字已经存在，不会替换成功</p>
<p>setTimeout, expire<br>设定一个key的活动时间（s）<br>$redis-&gt;setTimeout(‘x’, 3);</p>
<p>expireAt<br>key存活到一个unix时间戳时间<br>$redis-&gt;expireAt(‘x’, time() + 3);</p>
<p>keys, getKeys<br>返回满足给定pattern的所有key<br>$keyWithUserPrefix = $redis-&gt;keys(‘user*’);</p>
<p>dbSize<br>查看现在数据库有多少key<br>$count = $redis-&gt;dbSize();</p>
<p>auth<br>密码认证<br>$redis-&gt;auth(‘foobared’);</p>
<p>bgrewriteaof<br>使用aof来进行数据库持久化<br>$redis-&gt;bgrewriteaof();</p>
<p>slaveof<br>选择从服务器<br>$redis-&gt;slaveof(‘10.0.1.7’, 6379);</p>
<p>save<br>将数据同步保存到磁盘</p>
<p>bgsave<br>将数据异步保存到磁盘</p>
<p>lastSave<br>返回上次成功将数据保存到磁盘的Unix时戳</p>
<p>info<br>返回redis的版本信息等详情</p>
<p>type<br>返回key的类型值<br>string: Redis::REDIS_STRING<br>set: Redis::REDIS_SET<br>list: Redis::REDIS_LIST<br>zset: Redis::REDIS_ZSET<br>hash: Redis::REDIS_HASH<br>other: Redis::REDIS_NOT_FOUND</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>php-fpm.conf重要参数详解</title>
    <url>/2017/08/18/php-fpm-conf%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>pid = run/php-fpm.pid</p>
<p>#pid设置，默认在安装目录中的var/run/php-fpm.pid，建议开启</p>
<p>error_log = log/php-fpm.log</p>
<p>#错误日志，默认在安装目录中的var/log/php-fpm.log</p>
<p>error_log = log/php-fpm.log</p>
<p>#错误日志，默认在安装目录中的var/log/php-fpm.log</p>
<p>log_level = notice</p>
<p>#错误级别. 可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice.</p>
<a id="more"></a>

<p>emergency_restart_threshold = 60<br>emergency_restart_interval = 60s</p>
<p>#表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。</p>
<p>process_control_timeout = 0</p>
<p>#设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0.</p>
<p>daemonize = yes</p>
<p>#后台执行fpm,默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置</p>
<p>listen = 127.0.0.1:9000</p>
<p>#fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: ‘ip:port’, ‘port’, ‘/path/to/unix/socket’. 每个进程池都需要设置.</p>
<p>user = www<br>group = www</p>
<p>#启动进程的帐户和组</p>
<p>pm = dynamic</p>
<p>#对于专用服务器，pm可以设置为static。</p>
<p>#如何控制子进程，选项有static和dynamic。如果选择static，则由pm.max_children指定固定的子进程数。如果选择dynamic，则由下开参数决定：<br>pm.max_children #，子进程最大数<br>pm.start_servers #，启动时的进程数<br>pm.min_spare_servers #，保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程<br>pm.max_spare_servers #，保证空闲进程数最大值，如果空闲进程大于此值，此进行清理</p>
<p>pm.max_requests = 1000</p>
<p>#设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 ‘0’ 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0.</p>
<p>pm.status_path = /status</p>
<p>#FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到</p>
<p>ping.path = /ping</p>
<p>#FPM监控页面的ping网址. 如果没有设置, 则无法访问ping页面. 该页面用于外部检测FPM是否存活并且可以响应请求. 请注意必须以斜线开头 (/)。</p>
<p>request_terminate_timeout = 20  </p>
<p>#设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的’max_execution_time’因为某些特殊原因没有中止运行的脚本有用. 设置为 ‘0’ 表示 ‘Off’.当经常出现502错误时可以尝试更改此选项。这个时长配置可以在php.ini（max_execution_time）或php-fpm.conf中配置均可，为了不影响全局配置，可在php-fpm.conf中实现。</p>
<p>值得注意的是：需要结合nginx.conf中的max_fail（调大些）和fail_timeout（调小些）一同配置。</p>
<p>rlimit_files = 1024</p>
<p>#设置文件打开描述符的rlimit限制. 默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。</p>
<p>hp-fpm参数调优</p>
<p>pm = dynamic;</p>
<p>表示使用哪种进程数量管理方式</p>
<p>dynamic表示php-fpm进程数是动态的，最开始是pm.start_servers指定的数量，如果请求较多，则会自动增加，保证空闲的进程数不小于pm.min_spare_servers，如果进程数较多，也会进行相应清理，保证多余的进程数不多于pm.max_spare_servers</p>
<p>static表示php-fpm进程数是静态的, 进程数自始至终都是pm.max_children指定的数量，不再增加或减少</p>
<p>pm.max_children = 300;    静态方式下开启的php-fpm进程数量<br>pm.start_servers = 20;    动态方式下的起始php-fpm进程数量<br>pm.min_spare_servers = 5;    动态方式下的最小php-fpm进程数量<br>pm.max_spare_servers = 35;    动态方式下的最大php-fpm进程数量</p>
<p>request_terminate_timeout = 20;    最长执行时间优化（php.ini） 这个是用来处理因为PHP执行时间超长而报502错误的解决</p>
<p>最大执行时间, 在php.ini中也可以进行配置(max_execution_time)</p>
<p>rlimit_files = 10240; 增加php-fpm打开文件描述符的限制</p>
<p>pm.max_requests = 1000;  最大请求数优化 最大请求数：指一个php-fpm的工作进程在处理多少个请求后就终止掉。</p>
<p>nginx php-fpm配置过程中最大问题是内泄漏出问题：服务器的负载不大，但是内存占用迅速增加，很快吃掉内存接着开始吃交换分区，系统很快挂掉！其实根据官方的介绍，php-cgi不存在内存泄漏，每个请求完成后php-cgi会回收内存，但是不会释放给操作系统，这样就会导致大量内存被php-cgi占用。</p>
<p>官方的解决办法是降低PHP_FCGI_MAX_REQUESTS的值，如果用的是php-fpm，对应的php-fpm.conf中的就是max_requests，该值的意思是发送多少个请求后会重启该线程，我们需要适当降低这个值，用以让php-fpm自动的释放内存，不是大部分网上说的51200等等，实际上还有另一个跟它有关联的值max_children，这个是每次php-fpm会建立多少个进程，这样实际上的内存消耗是max_children<em>max_requests</em>每个请求使用内存，根据这个我们可以预估一下内存的使用情况，就不用再写脚本去kill了。</p>
<p>查看php-fpm进程数：</p>
<p>ps aux | grep -c php-fpm</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title>搭建服务器</title>
    <url>/2017/07/28/%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h3 id="1-执行安装命令"><a href="#1-执行安装命令" class="headerlink" title="1. 执行安装命令"></a>1. 执行安装命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure>

<p>正常情况：执行完上述安装命令，将会显示账号的关键信息：端口和UUID</p>
<a id="more"></a>

<h3 id="2-启动服务"><a href="#2-启动服务" class="headerlink" title="2. 启动服务"></a>2. 启动服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start ***</span><br></pre></td></tr></table></figure>

<ul>
<li>IP 地址：服务器的 IP 地址</li>
<li>端口：账号显示的端口</li>
<li>用户 UUID：账号显示的 UUID</li>
<li>额外 UD：默认是 64</li>
<li>加密方式：随便选择，移动端一般建议移动端选择 chacha20-poly-1305，桌面端选择 aes-128-gcm</li>
<li>其它选择项：保持默认即可，一般可以自由设置的还有路由选项和是否开启Mux 多路复用（开启 Mux 可能会提升速度，但也有几率出现断流，如播放视频突然无法缓冲）</li>
</ul>
<h3 id="3-修改配置"><a href="#3-修改配置" class="headerlink" title="3. 修改配置"></a>3. 修改配置</h3><p>更换传输协议、端口和 UUID，可以修改<code>/etc/***/</code>目录下的config.json文件。修改保存后，重启即可生效。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>PHP的反射机制</title>
    <url>/2017/06/20/PHP%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>介绍：</p>
<p>PHP5添加了一项新的功能：Reflection。这个功能使得phper可以reverse-engineer class, interface,function,method and extension。通过PHP代码，就可以得到某object的所有信息，并且可以和它交互。<br>反射是什么？<br>它是指在PHP运行状态中，扩展分析PHP程序，导出或提取出关于类、方法、属性、参数等的详细信息，包括注释。这种动态获取的信息以及动态调用对象的方法的功能称为反射API。反射是操纵面向对象范型中元模型的API，其功能十分强大，可帮助我们构建复杂，可扩展的应用。<br>其用途如：自动加载插件，自动生成文档，甚至可用来扩充PHP语言。</p>
<a id="more"></a>

<p>php反射api由若干类组成，可帮助我们用来访问程序的元数据或者同相关的注释交互。借助反射我们可以获取诸如类实现了那些方法，创建一个类的实例（不同于用new创建），调用一个方法（也不同于常规调用），传递参数，动态调用类的静态方法。<br>反射api是php内建的oop技术扩展，包括一些类，异常和接口，综合使用他们可用来帮助我们分析其它类，接口，方法，属性，方法和扩展。这些oop扩展被称为反射。<br>通过ReflectionClass，我们可以得到Person类的以下信息：</p>
<pre><code>1）常量 Contants

2）属性 Property Names

3）方法 Method Names静态

4）属性 Static Properties

5）命名空间 Namespace

6)Person类是否为final或者abstract</code></pre><p>例子<br>class Person {<br>    /**<br>     * For the sake of demonstration, we”re setting this private<br>     */<br>    private $_allowDynamicAttributes = false;  </p>
<pre><code>/** type=primary_autoincrement */  
protected $id = 0;  

/** type=varchar length=255 null */  
protected $name;  

/** type=text null */  
protected $biography;  

    public function getId()  
    {  
        return $this-&gt;id;  
    }  
    public function setId($v)  
    {  
        $this-&gt;id = $v;  
    }  
    public function getName()  
    {  
        return $this-&gt;name;  
    }  
    public function setName($v)  
    {  
        $this-&gt;name = $v;  
    }  
    public function getBiography()  
    {  
        return $this-&gt;biography;  
    }  
    public function setBiography($v)  
    {  
        $this-&gt;biography = $v;  
    }  </code></pre><p>}<br>接下来反射它，只要把类名”Person”传递给ReflectionClass就可以了：</p>
<p>$class = new ReflectionClass(‘Person’);//建立 Person这个类的反射类  </p>
<p>$instance  = $class-&gt;newInstanceArgs($args);//相当于实例化Person 类  </p>
<p>1）获取属性(Properties)：<br>$properties = $class-&gt;getProperties();<br>foreach($properties as $property) {<br>    echo $property-&gt;getName().”\n”;<br>}<br>// 输出:<br>// _allowDynamicAttributes<br>// id<br>// name<br>// biography<br>默认情况下，ReflectionClass会获取到所有的属性，private 和 protected的也可以。如果只想获取到private属性，就要额外传个参数：<br>$private_properties = $class-&gt;getProperties(ReflectionProperty::IS_PRIVATE);<br>可用参数列表：<br>               ReflectionProperty::IS_STATIC<br>               ReflectionProperty::IS_PUBLIC<br>               ReflectionProperty::IS_PROTECTED<br>               ReflectionProperty::IS_PRIVATE<br>如果要同时获取public 和private 属性，就这样写：ReflectionProperty::IS_PUBLIC | ReflectionProperty::IS_PROTECTED。</p>
<p>通过$property-&gt;getName()可以得到属性名。</p>
<p>2）获取注释：<br> 通过getDocComment可以得到写给property的注释。</p>
<p>foreach($properties as $property) {  </p>
<pre><code>if($property-&gt;isProtected()) {  

    $docblock = $property-&gt;getDocComment();  

    preg_match(&apos;/ type\=([a-z_]*) /&apos;, $property-&gt;getDocComment(), $matches);  

    echo $matches[1].&quot;\n&quot;;  

}  </code></pre><p>}  </p>
<p>// Output:  </p>
<p>// primary_autoincrement  </p>
<p>// varchar  </p>
<p>// text  </p>
<p>3）获取类的方法<br>获取方法(methods)：通过getMethods() 来获取到类的所有methods。</p>
<p>4）执行类的方法：<br>$instance-&gt;getBiography(); //执行Person 里的方法getBiography<br>//或者：<br>$ec=$class-&gt;getmethod(‘getName’);  //获取Person 类中的getName方法<br>$ec-&gt;invoke($instance);       //执行getName 方法  </p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP防止表单重复提交的几种常用方法汇总</title>
    <url>/2017/05/28/PHP%E9%98%B2%E6%AD%A2%E8%A1%A8%E5%8D%95%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>本文较为详细的汇总了PHP防止表单重复提交的几种常用方法，在PHP程序开发中有着很高的实用价值。具体方法如下：</p>
<p>1、使用JS让按钮在点击一次后禁用（disable）。采用这种方法可以防止多次点击的发生，实现方式较简单。</p>
<p>缺点是若客户端禁止JavaScript脚本，则失效。</p>
<p>2、在提交成功后执行页面重定向（redirect）。转到提交成功信息页面。</p>
<p>特点：避免F5重复提交，消除浏览器前进和后退按钮可导致的同样问题。</p>
<p>3、表单隐藏域中存放session（表单被请求时生成的标记）。采用此方法在接收表单数据后，检查此标志值是否存在，先进行删除，然后处理数据；若不存在，说明已提交过，忽略本次提交。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//服务端生成随机数存入session, 分配至表单页</span><br><span class="line">$data[&apos;sess_id&apos;] = $_SESSION[&apos;sid&apos;] = mt_rand(1000, 9999);</span><br><span class="line">$this-&gt;load-&gt;view(&apos;form&apos;, $data);</span><br><span class="line"></span><br><span class="line">//表单页隐藏域存放此session值</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;sid&quot; value=&quot;&lt;?=$sess_id; ?&gt;&quot;&gt;</span><br><span class="line"></span><br><span class="line">//处理</span><br><span class="line">if($_POST[&apos;sid&apos;] != &apos;&apos; &amp;&amp; $_POST[&apos;sid&apos;] == $_SESSION[&apos;sid&apos;])</span><br><span class="line">&#123;</span><br><span class="line">　unset($_SESSION[&apos;sid&apos;]);</span><br><span class="line"></span><br><span class="line">　echo &apos;处理数据&apos;;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">　echo &apos;已提交过表单&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、数据库唯一索引约束（最有效的防止重复数据的方法）。</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Linux的Crontab定时执行PHP脚本</title>
    <url>/2017/05/08/%E4%BD%BF%E7%94%A8Linux%E7%9A%84Crontab%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8CPHP%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>我们的PHP程序有时候需要定时执行，我们可以使用ignore_user_abort函数或是在页面放置js让用户帮我们实现。但这两种方法都不太可靠，不稳定。我们可以借助Linux的Crontab工具来稳定可靠地触发PHP执行任务。</p>
<p>下面介绍Crontab的两种方法。</p>
<a id="more"></a>

<p>一、在Crontab中使用PHP执行脚本 </p>
<p>就像在Crontab中调用普通的shell脚本一样（具体Crontab用法），使用PHP程序来调用PHP脚本。<br>每一小时执行myscript.php如下： </p>
<p># crontab -e<br>00 * * * * /usr/local/bin/php /home/john/myscript.php</p>
<p>/usr/local/bin/php为PHP程序的路径。</p>
<p>二、在Crontab中使用URL执行脚本</p>
<p>如果你的PHP脚本可以通过URL触发，你可以使用lynx或curl或wget来配置你的Crontab。<br>下面的例子是使用Lynx文本浏览器访问URL来每小时执行PHP脚本。Lynx文本浏览器默认使用对话方式打开URL。但是，像下面的，我们在lynx命令行中使用-dump选项来把URL的输出转换来标准输出。</p>
<p>代码如下:</p>
<p>0 * * * * lynx -dump <a href="http://www.jb51.net/myscript.php" target="_blank" rel="noopener">http://www.jb51.net/myscript.php</a></p>
<p>下面的例子是使用CURL访问URL来每5分执行PHP脚本。Curl默认在标准输出显示输出。使用”curl -o”选项，你也可以把脚本的输出转储到临时文件。 </p>
<p>*/5 * * * * /usr/bin/curl -o temp.txt <a href="http://www.jb51.net/myscript.php" target="_blank" rel="noopener">http://www.jb51.net/myscript.php</a></p>
<p>下面的例子是使用WGET访问URL来每10分执行PHP脚本。-q选项表示安静模式。”-O temp.txt”表示输出会发送到临时文件。 </p>
<p>*/10 * * * * /usr/bin/wget -q -O temp.txt <a href="http://www.jb51.net/myscript.php" target="_blank" rel="noopener">http://www.jb51.net/myscript.php</a> </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch-1.7.1 Windows版本安装</title>
    <url>/2017/04/12/Elasticsearch-1.7.1%20install/</url>
    <content><![CDATA[<p>1、首先下载最新的elasticsearch安装版本，以下为官网下载地址：</p>
<p><a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/downloads/elasticsearch</a></p>
<p>下载完成后，解压缩在安装目录。</p>
<a id="more"></a>

<p>​2、安装JAVA环境</p>
<p>​<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3MxNi5zaW5haW1nLmNuL213NjkwLzAwNjlRMFZ0Z3k2VU80SU1WQTNkZg?x-oss-process=image/format,png" alt="﻿Java SE下载"></p>
<p>选择合适的版本下载安装，然后配置环境变量。</p>
<p>(1)新建名为classpath的变量名，变量值为</p>
<p>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</p>
<p>(2)新建名为JAVA_HOME的变量名，变量值为之前安装jdk的目录，例如D:\Java\jdk1.7.0_79</p>
<p>(3)在已有的系统变量path的变量值加上</p>
<p>;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</p>
<p>自此配置完成，运行cmd命令，输入java回车​，出现以下结果表示配置成功。​</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3MyLnNpbmFpbWcuY24vbXc2OTAvMDA2OVEwVnRneTZVTzVFcXdzOWUx?x-oss-process=image/format,png" alt="﻿"></p>
<p>3、运行-&gt;cmd，进入elasticsearch安装目录，再进入bin目录，运行elasticsearch.bat：</p>
<p>启动成功后，在浏览器中输入:<a href="http://localhost:9200/" target="_blank" rel="noopener">http://localhost:9200/</a></p>
<p>{</p>
<p>  “status” : 200,</p>
<p>  “name” : “Living Mummy”,</p>
<p>  “cluster_name” : “elasticsearch”,</p>
<p>  “version” : {</p>
<pre><code>&quot;number&quot; : &quot;1.7.1&quot;,

&quot;build_hash&quot; : &quot;b88f43fc40b0bcd7f173a1f9ee2e97816de80b19&quot;,

&quot;build_timestamp&quot; : &quot;2015-07-29T09:54:16Z&quot;,

&quot;build_snapshot&quot; : false,

&quot;lucene_version&quot; : &quot;4.10.4&quot;</code></pre><p>  },</p>
<p>  “tagline” : “You Know, for Search”</p>
<p>}</p>
<p>表示安装成功了。​</p>
<p>4、将elasticsearch安装成系统服务​</p>
<p>(1). 在Linux上运行系统服务</p>
<p>如果是从提供的二进制包安装的Elasticsearch，你已经完成了，什么都不用担心。但是，如果你刚刚下载归档文件，解压到所选择的目录，就需要做一些额外的工作。为了将Elasticsearch安装成一个Linux系统服务，将使用Elasticsearch service wrapper，你可以从<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> elasticsearch/elasticsearch-servicewrapper下载。</p>
<p>来看看使用Elasticsearch service wrapper建立Elasticsearch Linux服务的步骤。首先，执行以下命令来下载这个wrapper：</p>
<p>curl -L <a href="http://github.com/elasticsearch/elasticsearch-" target="_blank" rel="noopener">http://github.com/elasticsearch/elasticsearch-</a></p>
<p>servicewrapper/tarball/master</p>
<p>tar -xz</p>
<p>假设Elasticsearch已经安装在/usr/local/share/elasticsearch下，执行如下命令来移动所需的wrapper文件：</p>
<p>sudo mv <em>servicewrapper</em>/service/usr/local/share/elasticsearch/bin/</p>
<p>执行如下命令来移除剩余的文件</p>
<p>rm -Rf <em>servicewrapper</em></p>
<p>最后，通过执行install命令来安装服务：</p>
<p>sudo /usr/local/share/elasticsearch/bin/service/elasticsearch install</p>
<p>在这之后，需要创建一个符号链接指向/usr/local/bin/rcelasticsearch下的/usr/local/share/elasticsearch/bin/service/elasticsearch脚本。可通过运行如下命令来实现：</p>
<p>sudo ln -s ‘readlink -f</p>
<p>/usr/local/share/elasticsearch/bin/service/elasticsearch’</p>
<p>/usr/local/bin/rcelasticsearch</p>
<p>就这样。如果你想启动Elasticsearch，执行如下命令：</p>
<p>/etc/init.d/elasticsearch start</p>
<p>(2). 在Windows上运行系统服务</p>
<p>在Windows下把Elasticsearch安装为系统服务非常容易，你只需转到Elasticsearch的安装目录，到bin子目录下，执行:</p>
<p>service.bat install</p>
<p>你会被问及操作权限，允许脚本运行，Elasticsearch就被安装成一个Windows服务。</p>
<p>如果你想看看所有被service.bat脚本文件暴露出来的命令，在相同目录下执行：</p>
<p>service.bat</p>
<p>例如，为了启动Elasticsearch，可执行如下命令：</p>
<p>service.bat start</p>
<hr>
<p>elasticsearch插件elasticsearch-head安装：</p>
<p>elasticsearch-head是一个elasticsearch的集群管理工具，它是完全由html5编写的独立网页程序，你可以通过插件把它集成到es。</p>
<p>在cmd命令行中进入安装目录，再进入 bin目录，运行以下命令：</p>
<p>plugin -install mobz/elasticsearch-head</p>
<p>然后安装成功后，\plugins目录下会有head的文件夹。在浏览器中输入:<a href="http://localhost:9200/_plugin/head/，可以看到效果。" target="_blank" rel="noopener">http://localhost:9200/_plugin/head/，可以看到效果。</a></p>
<p>elasticsearch插件bigdesk安装：</p>
<p>bigdesk是elasticsearch的一个集群监控工具，可以通过它来查看es集群的各种状态，如：cpu、内存使用情况，索引数据、搜索情况，http连接数等。</p>
<p>在cmd命令行中进入安装目录，再进入 bin目录，运行以下命令：</p>
<p>plugin -install lukas-vlcek/bigdesk</p>
<p>然后安装成功后，在浏览器中输入:<a href="http://localhost:9200/_plugin/bigdesk/，可以看到效果。" target="_blank" rel="noopener">http://localhost:9200/_plugin/bigdesk/，可以看到效果。</a></p>
]]></content>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache局域网内ip配置</title>
    <url>/2017/04/10/Apache%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85ip%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Directory /&gt;</span><br><span class="line"></span><br><span class="line">    Options FollowSymLinks</span><br><span class="line">    AllowOverride ALL</span><br><span class="line">    Order deny,allow</span><br><span class="line">    Allow from all</span><br><span class="line"></span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>

<p>配置虚拟主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost 192.168.0.18&gt;        </span><br><span class="line">DocumentRoot &quot;D:/wamp/www&quot;</span><br><span class="line">ServerName 192.168.0.18</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法详解</title>
    <url>/2017/04/02/Markdown/</url>
    <content><![CDATA[<h1 id="Cmd-Markdown-简明语法手册"><a href="#Cmd-Markdown-简明语法手册" class="headerlink" title="Cmd Markdown 简明语法手册"></a>Cmd Markdown 简明语法手册</h1><hr>
<h2 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a>1. 斜体和粗体</h2><p>使用 * 和 ** 表示斜体和粗体。</p>
<p>示例：</p>
<p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p>
<h2 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h2><p>使用 === 表示一级标题，使用 --- 表示二级标题。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一个一级标题</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">这是一个二级标题</span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">### 这是一个三级标题</span><br></pre></td></tr></table></figure>

<p>你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。</p>
<h2 id="3-外链接"><a href="#3-外链接" class="headerlink" title="3. 外链接"></a>3. 外链接</h2><p>使用 [描述](链接地址) 为文字增加外链接。</p>
<p>示例：</p>
<p>这是去往 <a href="https://weimjay.github.io" target="_blank" rel="noopener">本人博客</a> 的链接。</p>
<h2 id="4-无序列表"><a href="#4-无序列表" class="headerlink" title="4. 无序列表"></a>4. 无序列表</h2><p>使用 *，+，- 表示无序列表。</p>
<p>示例：</p>
<ul>
<li>无序列表项 一</li>
<li>无序列表项 二</li>
<li>无序列表项 三</li>
</ul>
<h2 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. 有序列表</h2><p>使用数字和点表示有序列表。</p>
<p>示例：</p>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<a id="more"></a>

<h2 id="6-文字引用"><a href="#6-文字引用" class="headerlink" title="6. 文字引用"></a>6. 文字引用</h2><p>使用 &gt; 表示文字引用。</p>
<p>示例：</p>
<blockquote>
<p>野火烧不尽，春风吹又生。</p>
</blockquote>
<h2 id="7-行内代码块"><a href="#7-行内代码块" class="headerlink" title="7. 行内代码块"></a>7. 行内代码块</h2><p>使用 `代码` 表示行内代码块。</p>
<p>示例：</p>
<p>让我们聊聊 <code>html</code>。</p>
<h2 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.  代码块"></a>8.  代码块</h2><p>使用 四个缩进空格 表示代码块。</p>
<p>示例：</p>
<pre><code>这是一个代码块，此行左侧有四个不可见的空格。</code></pre><h2 id="9-插入图像"><a href="#9-插入图像" class="headerlink" title="9.  插入图像"></a>9.  插入图像</h2><p>使用 ![描述](图片链接地址) 插入图像。</p>
<p>示例：</p>
<p><img src="https://www.zybuluo.com/static/img/logo.png" alt="logo"></p>
<hr>
<h1 id="Cmd-Markdown-高阶语法手册"><a href="#Cmd-Markdown-高阶语法手册" class="headerlink" title="Cmd Markdown 高阶语法手册"></a>Cmd Markdown 高阶语法手册</h1><h2 id="1-内容目录"><a href="#1-内容目录" class="headerlink" title="1. 内容目录"></a>1. 内容目录</h2><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p>
<p>[TOC]</p>
<h2 id="2-标签分类"><a href="#2-标签分类" class="headerlink" title="2. 标签分类"></a>2. 标签分类</h2><p>在编辑区任意行的列首位置输入以下代码给文稿标签：</p>
<p>标签： 数学 英语 Markdown</p>
<p>或者</p>
<p>Tags： 数学 英语 Markdown</p>
<h2 id="3-删除线"><a href="#3-删除线" class="headerlink" title="3. 删除线"></a>3. 删除线</h2><p>使用 ~~ 表示删除线。</p>
<p><del>这是一段错误的文本。</del></p>
<h2 id="4-注脚"><a href="#4-注脚" class="headerlink" title="4. 注脚"></a>4. 注脚</h2><p>使用 [^keyword] 表示注脚。</p>
<p>这是一个注脚[^footnote]的样例。</p>
<p>这是第二个注脚[^footnote2]的样例。</p>
<h2 id="5-LaTeX-公式"><a href="#5-LaTeX-公式" class="headerlink" title="5. LaTeX 公式"></a>5. LaTeX 公式</h2><p>$ 表示行内公式： </p>
<p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>
<p>$$ 表示整行公式：</p>
<p>$$\sum_{i=1}^n a_i=0$$</p>
<p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p>
<p>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p>
<p>访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p>
<h2 id="6-加强的代码块"><a href="#6-加强的代码块" class="headerlink" title="6. 加强的代码块"></a>6. 加强的代码块</h2><p>支持四十一种编程语言的语法高亮的显示，行号显示。</p>
<p>非代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install vim-gnome</span><br></pre></td></tr></table></figure>

<p>Python 示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* nth element in the fibonacci series.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>n &gt;= 0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return </span>the nth element, &gt;= 0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a += b;</span><br><span class="line">    b = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(fib(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<h2 id="7-流程图"><a href="#7-流程图" class="headerlink" title="7. 流程图"></a>7. 流程图</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st=&gt;start: Start:&gt;https://www.zybuluo.com</span><br><span class="line">io=&gt;inputoutput: verification</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">sub=&gt;subroutine: Your Subroutine</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;io-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;sub-&gt;io</span><br></pre></td></tr></table></figure>

<h3 id="更多语法参考：流程图语法参考"><a href="#更多语法参考：流程图语法参考" class="headerlink" title="更多语法参考：流程图语法参考"></a>更多语法参考：<a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">流程图语法参考</a></h3><h2 id="8-序列图"><a href="#8-序列图" class="headerlink" title="8. 序列图"></a>8. 序列图</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title: Here is a title</span><br><span class="line">A-&gt;B: Normal line</span><br><span class="line">B--&gt;C: Dashed line</span><br><span class="line">C-&gt;&gt;D: Open arrow</span><br><span class="line">D--&gt;&gt;A: Dashed open arrow</span><br></pre></td></tr></table></figure>

<h3 id="更多语法参考：序列图语法参考"><a href="#更多语法参考：序列图语法参考" class="headerlink" title="更多语法参考：序列图语法参考"></a>更多语法参考：<a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">序列图语法参考</a></h3><h2 id="9-甘特图"><a href="#9-甘特图" class="headerlink" title="9. 甘特图"></a>9. 甘特图</h2><p>甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure>

<h3 id="更多语法参考：甘特图语法参考"><a href="#更多语法参考：甘特图语法参考" class="headerlink" title="更多语法参考：甘特图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#gant-diagrams" target="_blank" rel="noopener">甘特图语法参考</a></h3><h2 id="10-Mermaid-流程图"><a href="#10-Mermaid-流程图" class="headerlink" title="10. Mermaid 流程图"></a>10. Mermaid 流程图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class="line">B --&gt; C&#123;Decision&#125;</span><br><span class="line">C --&gt;|One| D[Result one]</span><br><span class="line">C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure>

<h3 id="更多语法参考：Mermaid-流程图语法参考"><a href="#更多语法参考：Mermaid-流程图语法参考" class="headerlink" title="更多语法参考：Mermaid 流程图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#flowcharts-basic-syntax" target="_blank" rel="noopener">Mermaid 流程图语法参考</a></h3><h2 id="11-Mermaid-序列图"><a href="#11-Mermaid-序列图" class="headerlink" title="11. Mermaid 序列图"></a>11. Mermaid 序列图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice-&gt;John: Hello John, how are you?</span><br><span class="line">loop every minute</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="更多语法参考：Mermaid-序列图语法参考"><a href="#更多语法参考：Mermaid-序列图语法参考" class="headerlink" title="更多语法参考：Mermaid 序列图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#sequence-diagrams" target="_blank" rel="noopener">Mermaid 序列图语法参考</a></h3><h2 id="12-表格支持"><a href="#12-表格支持" class="headerlink" title="12. 表格支持"></a>12. 表格支持</h2><table>
<thead>
<tr>
<th>项目</th>
<th align="right">价格</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td>计算机</td>
<td align="right">$1600</td>
<td align="center">5</td>
</tr>
<tr>
<td>手机</td>
<td align="right">$12</td>
<td align="center">12</td>
</tr>
<tr>
<td>管线</td>
<td align="right">$1</td>
<td align="center">234</td>
</tr>
</tbody></table>
<h2 id="13-定义型列表"><a href="#13-定义型列表" class="headerlink" title="13. 定义型列表"></a>13. 定义型列表</h2><dl><dt>名词 1</dt><dd>定义 1（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><dl><dt>代码块 2</dt><dd>这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><pre><code>代码块（左侧有八个不可见的空格）</code></pre><h2 id="14-Html-标签"><a href="#14-Html-标签" class="headerlink" title="14. Html 标签"></a>14. Html 标签</h2><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：</p>
<pre><code>&lt;table&gt;
    &lt;tr&gt;
        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;
        &lt;th&gt;星期一&lt;/th&gt;
        &lt;th&gt;星期二&lt;/th&gt;
        &lt;th&gt;星期三&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;李强&lt;/td&gt;
        &lt;td&gt;张明&lt;/td&gt;
        &lt;td&gt;王平&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;</code></pre><table>
    <tr>
        <th rowspan="2">值班人员</th>
        <th>星期一</th>
        <th>星期二</th>
        <th>星期三</th>
    </tr>
    <tr>
        <td>李强</td>
        <td>张明</td>
        <td>王平</td>
    </tr>
</table>

<h2 id="15-内嵌图标"><a href="#15-内嵌图标" class="headerlink" title="15. 内嵌图标"></a>15. 内嵌图标</h2><p>本站的图标系统对外开放，在文档中输入</p>
<pre><code>&lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;</code></pre><p>即显示微博的图标： <i class="icon-weibo icon-2x"></i></p>
<p>替换 上述 <code>i 标签</code> 内的 <code>icon-weibo</code> 以显示不同的图标，例如：</p>
<pre><code>&lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;</code></pre><p>即显示人人的图标： <i class="icon-renren icon-2x"></i></p>
<p>更多的图标和玩法可以参看 <a href="http://fortawesome.github.io/Font-Awesome/3.2.1/icons/" target="_blank" rel="noopener">font-awesome</a> 官方网站。</p>
<h2 id="16-待办事宜-Todo-列表"><a href="#16-待办事宜-Todo-列表" class="headerlink" title="16. 待办事宜 Todo 列表"></a>16. 待办事宜 Todo 列表</h2><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p>
<pre><code>- [ ] **Cmd Markdown 开发**
    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率
    - [ ] 支持以 PDF 格式导出文稿
    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)
    - [x] 改进 LaTex 功能
        - [x] 修复 LaTex 公式渲染问题
        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)
- [ ] **七月旅行准备**
    - [ ] 准备邮轮上需要携带的物品
    - [ ] 浏览日本免税店的物品
    - [x] 购买蓝宝石公主号七月一日的船票</code></pre><p>对应显示如下待办事宜 Todo 列表：</p>
<ul>
<li><input disabled type="checkbox"> <strong>Cmd Markdown 开发</strong><ul>
<li><input disabled type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li><input disabled type="checkbox"> 支持以 PDF 格式导出文稿</li>
<li><input checked disabled type="checkbox"> 新增Todo列表功能 <a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments" target="_blank" rel="noopener">语法参考</a></li>
<li><input checked disabled type="checkbox"> 改进 LaTex 功能<ul>
<li><input checked disabled type="checkbox"> 修复 LaTex 公式渲染问题</li>
<li><input checked disabled type="checkbox"> 新增 LaTex 公式编号功能 <a href="http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers" target="_blank" rel="noopener">语法参考</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled type="checkbox"> <strong>七月旅行准备</strong><ul>
<li><input disabled type="checkbox"> 准备邮轮上需要携带的物品</li>
<li><input disabled type="checkbox"> 浏览日本免税店的物品</li>
<li><input checked disabled type="checkbox"> 购买蓝宝石公主号七月一日的船票</li>
</ul>
</li>
</ul>
<p>[^footnote]: 这是一个 <em>注脚</em> 的 <strong>文本</strong>。</p>
<p>[^footnote2]: 这是另一个 <em>注脚</em> 的 <strong>文本</strong>。</p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Github + Hexo 搭建静态博客</title>
    <url>/2017/04/02/Github%20+%20Hexo/</url>
    <content><![CDATA[<h2 id="为什么选择GitHub-Pages？"><a href="#为什么选择GitHub-Pages？" class="headerlink" title="为什么选择GitHub Pages？"></a>为什么选择GitHub Pages？</h2><ul>
<li>1、github pages有300M免费空间，资料自己管理，保存可靠；</li>
<li>2、可定制性极强，可以结合Hexo框架搭建静态博客，不需要数据库，访问速度快；</li>
<li>3、github是世界上最大的技术分享网站，使用它能让我们眼界更加开阔。</li>
</ul>
<h2 id="如何搭建静态博客？"><a href="#如何搭建静态博客？" class="headerlink" title="如何搭建静态博客？"></a>如何搭建静态博客？</h2><p>大概可以分为以下几个步骤</p>
<blockquote>
<p>1.搭建环境准备（包括node.js和git环境，github账户的配置）<br>2.Hexo的安装与配置<br>3.在Github Pages上部署Hexo框架<br>4.发布文章<br>5.主题NexT的简单配置<br>6.添加feed和sitemap插件<br>7.添加404公益页面</p>
</blockquote>
<a id="more"></a>

<h2 id="搭建环境准备"><a href="#搭建环境准备" class="headerlink" title="搭建环境准备"></a>搭建环境准备</h2><p>大概可以分为以下三步 </p>
<ul>
<li>Node.js 的安装和准备 </li>
<li>Git的安装和准备 </li>
<li>gitHub账户的配置</li>
</ul>
<h3 id="配置Node-js环境"><a href="#配置Node-js环境" class="headerlink" title="配置Node.js环境"></a>配置Node.js环境</h3><p>下载安装Node.js：<br><a href="https://nodejs.org" target="_blank" rel="noopener">https://nodejs.org</a></p>
<p>所有设置保持默认即可，安装完成后，检查是否安装正确，打开cmd命令行窗口，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。<br><img src="http://ww4.sinaimg.cn/large/9fe4afa0gw1faljiuibwdj20it0cb3zd.jpg" alt></p>
<h3 id="配置Git环境"><a href="#配置Git环境" class="headerlink" title="配置Git环境"></a>配置Git环境</h3><p>下载安装Git：<br><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p>
<p>和Node.js一样，大部分设置都只需要保持默认，但是出于我们操作方便考虑，建议PATH选项按照下图选择：<br>Git PATH设置<br><img src="http://ww4.sinaimg.cn/large/9fe4afa0gw1faljmop0mbj20dz0atwhi.jpg" alt></p>
<p>一样的，我们来检查一下Git是不是安装正确了，打开命令行，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。<br><img src="http://ww2.sinaimg.cn/large/9fe4afa0gw1faljp87tpkj20it0cbdgo.jpg" alt></p>
<h3 id="github账户的注册和配置"><a href="#github账户的注册和配置" class="headerlink" title="github账户的注册和配置"></a>github账户的注册和配置</h3><p>如果已经拥有账号，请跳过此步~</p>
<p>1.Github注册：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p>
<p>2.创建代码库<br>登陆之后，点击页面右上角的加号，选择New repository：<br><img src="http://ww2.sinaimg.cn/large/9fe4afa0gw1faljww56v8j20ci0a975c.jpg" alt></p>
<p>进入到代码库创建页面，在Repository name下填写yourname.github.io，Description (optional)下填写一些简单的描述（可选），如图所示：<br><img src="http://ww4.sinaimg.cn/large/9fe4afa0gw1faljv7hoqhj20p40fz0vo.jpg" alt></p>
<p>3.代码库设置<br>接下来开启Github pages功能，点击界面右侧的Settings，找到GitHub Pages，Source选择master branch，并保存。此时，如果配置正确，<a href="https://yourname.github.io" target="_blank" rel="noopener">https://yourname.github.io</a> 这个网址就可以正常访问了。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在自己认为合适的地方创建一个文件夹，这里我以E:\hexo 为例子讲解，首先在E盘目录下创建Hexo文件夹，并在命令行的窗口进入到该目录<br><img src="http://ww4.sinaimg.cn/large/9fe4afa0gw1falkb6ao3oj2064032a9x.jpg" alt></p>
<p>在命令行中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>然后你将会看到：<br><img src="http://ww3.sinaimg.cn/large/9fe4afa0gw1falkcr5z7kj20ce074aav.jpg" alt></p>
<p>可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。 然后输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure>

<p>等待hexo安装完成之后，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>

<p>如果你看到了如图文字，则说明已经安装成功了。<br><img src="http://ww2.sinaimg.cn/large/9fe4afa0gw1falkf052h7j205r06f0su.jpg" alt></p>
<h2 id="Hexo的相关配置"><a href="#Hexo的相关配置" class="headerlink" title="Hexo的相关配置"></a>Hexo的相关配置</h2><p>1.初始化Hexo<br>接着上面的操作，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>然后输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>之后npm将会自动安装你需要的组件，只需要等待npm操作即可。<br>2.首次体验Hexo<br>继续操作，同样是在命令行中，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p><img src="http://ww3.sinaimg.cn/large/9fe4afa0gw1falkiaws1xj208p045t9j.jpg" alt><br>然后输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>然后会提示：</p>
<blockquote>
<p>INFO   Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>. Press Ctrl+C to stop.</p>
</blockquote>
<p>在浏览器中打开<a href="http://localhost:4000/，你将会看到：" target="_blank" rel="noopener">http://localhost:4000/，你将会看到：</a><br><img src="http://ww4.sinaimg.cn/large/9fe4afa0gw1falkk5mnsvj211y0lcten.jpg" alt></p>
<p>到目前为止，Hexo在本地的配置已经全都结束了，下面会讲解如何Github pages上部署Hexo。</p>
<h2 id="在Github-Pages上部署Hexo"><a href="#在Github-Pages上部署Hexo" class="headerlink" title="在Github Pages上部署Hexo"></a>在Github Pages上部署Hexo</h2><h3 id="配置Git个人信息"><a href="#配置Git个人信息" class="headerlink" title="配置Git个人信息"></a>配置Git个人信息</h3><p>1、设置Git的user name和email：(如果是第一次的话)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;yourname@gmail.com&quot;</span><br></pre></td></tr></table></figure>

<p>检查是否已经有SSH Key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure>

<p>接着输入ls命令，列出该文件下的文件，看是否存在 id_isa 和 id_isa.pub 文件（也可以是别的文件名，只要 yourName 和 yourName.pub 承兑存在），如果有，证明已经存在 ssh key了，可以直接跳过生成密钥这一步骤。<br>下图是已经存在ssh key的情况：<br><img src="http://ww2.sinaimg.cn/large/9fe4afa0jw1famro8k282j20d3026jrq.jpg" alt></p>
<p>2、生成密钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;yourname@gmail.com&quot;</span><br></pre></td></tr></table></figure>

<p>如果不需要密码的话，连续3个回车。<br>最后生成了两个文件：id_rsa和id_rsa.pub，存储路径是C:\Users\Administrator.ssh</p>
<p>3、添加密钥到ssh-agent<br>确保 ssh-agent 是可用的。ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># start the ssh-agent in the background</span><br><span class="line">eval &quot;$(ssh-agent -s)&quot;</span><br></pre></td></tr></table></figure>

<p><img src="http://ww3.sinaimg.cn/large/9fe4afa0gw1fammrmpcbfj20as02eaad.jpg" alt><br>添加生成的 SSH key 到 ssh-agent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

<p>4、登陆Github, 添加ssh<br>Settings-&gt;Deploy keys-&gt;Add deploy key<br>Title名称自定义，把id_rsa.pub文件里的内容复制到Key里面，勾选Allow write access，保存：<br><img src="http://wx3.sinaimg.cn/large/0069Q0Vtgy1fe9kd1dw1uj30qx0bwq36.jpg" alt></p>
<p>5、测试ssh连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>下图表示连接成功<br><img src="http://wx3.sinaimg.cn/large/0069Q0Vtly1fe9k971ohgj30fk02qdfq.jpg" alt></p>
<h3 id="配置Deployment"><a href="#配置Deployment" class="headerlink" title="配置Deployment"></a>配置Deployment</h3><p>在根目录的_config.yml文件中，找到Deployment，然后按照如下修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><p>需要先安装一个扩展：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>新建一篇文章，执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post &quot;article title&quot;</span><br></pre></td></tr></table></figure>

<p>这时候在我的电脑的目录下 E:\hexo\source_posts 将会看到 article title.md 文件<br>用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g   // 生成</span><br><span class="line">hexo d   // 部署</span><br></pre></td></tr></table></figure>

<p>当然你也可以执行下面的命令，相当于上面两条命令的效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d -g #在部署前先生成</span><br></pre></td></tr></table></figure>

<p>注意：如果出现下面这样的错误</p>
<blockquote>
<p>Permission denied (publickey).<br>fatal: Could not read from remote repository.<br>Please make sure you have the correct access rights<br>and the repository exists.</p>
</blockquote>
<p>则是因为没有设置好public key所致。<br>在本机生成public key，不懂的可以参考<a href>Git ssh 配置及使用</a></p>
<h2 id="主题推荐"><a href="#主题推荐" class="headerlink" title="主题推荐"></a>主题推荐</h2><p><strong>NexT</strong><br>目前Github上Star最高的Hexo主题，支持几种不同的风格。<br>作者提供了非常完善的配置说明：<br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a></p>
<h2 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h2><p>添加feed和sitemap插件<br>切换到你本地的hexo目录，在命令行窗口，输入以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed -save</span><br><span class="line">npm install hexo-generator-sitemap -save</span><br></pre></td></tr></table></figure>

<p>修改_config.yml，增加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">Plugins:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">#sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br></pre></td></tr></table></figure>

<p>再执行以下命令，部署服务端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>

<h2 id="添加404页面"><a href="#添加404页面" class="headerlink" title="添加404页面"></a>添加404页面</h2><p>GitHub Pages有提供制作404页面的指引：<a href="https://help.github.com/articles/creating-a-custom-404-page-for-your-github-pages-site/" target="_blank" rel="noopener">Custom 404 Pages </a></p>
<p>对于已绑定域名的网站，GitHub 默认调用其根目录下的 404.html 作为 404 页面。我们可以利用 Hexo 的新建页面功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;404&quot;</span><br></pre></td></tr></table></figure>

<p>然后找到/source/404目录下的 index.md，在头部加入permalink: 404，部署后即可生效。（如不生效可用 permalink: 404.html）</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/04/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
